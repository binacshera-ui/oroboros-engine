//! # Dynamic World Manager
//!
//! Manages chunk loading/unloading based on player position.
//!
//! ## Design
//!
//! - Tracks player position and calculates active chunk region
//! - Loads chunks within 10-chunk radius
//! - Unloads chunks beyond 12-chunk radius
//! - Integrates with WAL for modified chunk persistence
//!
//! ## Performance
//!
//! - O(1) chunk lookup via HashMap
//! - **ASYNC** background generation for non-blocking gameplay
//! - Pre-allocated chunk pool to avoid allocations in hot path

use std::collections::{HashMap, HashSet, VecDeque};
use std::path::PathBuf;
use std::sync::mpsc::{channel, Receiver, Sender};
use std::sync::Arc;
#[cfg(not(target_arch = "wasm32"))]
use std::thread;
// WASM FIX: Use conditional time imports
#[cfg(not(target_arch = "wasm32"))]
use std::time::Instant;
#[cfg(target_arch = "wasm32")]
use web_time::Instant;

use crate::chunk::{Chunk, ChunkCoord, ChunkGenerator, CHUNK_SIZE};
use crate::noise::WorldSeed;

// =============================================================================
// ASYNC CHUNK GENERATION - SMOOTH ALPHA
// =============================================================================
/// Enable verbose streaming logs (set to false for production)
const ASYNC_VERBOSE: bool = false;

/// Configuration for the world manager.
#[derive(Clone, Debug)]
pub struct WorldManagerConfig {
    /// Radius (in chunks) to load around the player.
    pub load_radius: i32,
    /// Radius (in chunks) beyond which to unload.
    pub unload_radius: i32,
    /// Maximum chunks to generate per frame.
    pub max_chunks_per_frame: usize,
    /// Directory for chunk persistence.
    pub world_save_path: PathBuf,
}

impl Default for WorldManagerConfig {
    fn default() -> Self {
        Self {
            load_radius: 10,
            unload_radius: 12,
            max_chunks_per_frame: 4,
            world_save_path: PathBuf::from("world/chunks"),
        }
    }
}

impl WorldManagerConfig {
    /// Production configuration optimized for gameplay.
    #[must_use]
    pub fn production() -> Self {
        Self {
            load_radius: 10,
            unload_radius: 12,
            max_chunks_per_frame: 8, // More aggressive loading
            world_save_path: PathBuf::from("world/chunks"),
        }
    }

    /// Test configuration with smaller radius.
    #[must_use]
    pub fn test() -> Self {
        Self {
            load_radius: 3,
            unload_radius: 4,
            max_chunks_per_frame: 16,
            world_save_path: PathBuf::from("test_world/chunks"),
        }
    }
}

/// Result of a chunk query.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChunkState {
    /// Chunk is loaded and ready.
    Loaded,
    /// Chunk is queued for generation.
    Pending,
    /// Chunk is not in the active region.
    Unloaded,
}

/// Statistics about world management.
#[derive(Debug, Default, Clone)]
pub struct WorldStats {
    /// Number of chunks currently loaded.
    pub loaded_chunks: usize,
    /// Number of chunks pending generation.
    pub pending_chunks: usize,
    /// Number of chunks unloaded this session.
    pub unloaded_this_session: usize,
    /// Number of chunks generated this session.
    pub generated_this_session: usize,
    /// Number of modified chunks saved.
    pub saved_modified_chunks: usize,
}

/// Modification record for chunk persistence.
#[derive(Debug, Clone)]
pub struct ChunkModification {
    /// Local X coordinate within chunk.
    pub local_x: u8,
    /// Y coordinate.
    pub y: u8,
    /// Local Z coordinate within chunk.
    pub local_z: u8,
    /// New block type ID.
    pub block_id: u16,
    /// Timestamp of modification (server tick).
    pub tick: u64,
}

/// Entry in the chunk modification log.
#[derive(Debug, Clone)]
pub struct ModificationEntry {
    /// Chunk coordinate.
    pub coord: ChunkCoord,
    /// List of modifications.
    pub modifications: Vec<ChunkModification>,
}

/// Message sent to worker thread (Native only)
#[cfg_attr(target_arch = "wasm32", allow(dead_code))]
struct ChunkRequest {
    coord: ChunkCoord,
}

/// Message received from worker thread (Native only)
#[cfg_attr(target_arch = "wasm32", allow(dead_code))]
struct ChunkResult {
    coord: ChunkCoord,
    chunk: Chunk,
    gen_time_us: u64,
}

/// Dynamic world manager for infinite terrain.
///
/// Handles chunk loading, unloading, and persistence.
/// Uses async thread pool for non-blocking generation.
pub struct WorldManager {
    /// Chunk generator for procedural terrain (shared with workers).
    generator: Arc<ChunkGenerator>,
    /// Configuration.
    config: WorldManagerConfig,
    /// Currently loaded chunks.
    loaded_chunks: HashMap<ChunkCoord, Chunk>,
    /// Chunks queued for generation (waiting to be sent to workers).
    generation_queue: VecDeque<ChunkCoord>,
    /// Set of queued coords for O(1) lookup.
    queued_set: HashSet<ChunkCoord>,
    /// Chunks currently being generated by worker threads (Native only).
    #[cfg_attr(target_arch = "wasm32", allow(dead_code))]
    in_flight: HashSet<ChunkCoord>,
    /// Current player chunk position.
    player_chunk: ChunkCoord,
    /// Modification log for persistence.
    modification_log: HashMap<ChunkCoord, Vec<ChunkModification>>,
    /// Statistics.
    stats: WorldStats,
    /// Current server tick (for modification timestamps).
    current_tick: u64,
    /// Channel to send work to worker threads (Native only).
    #[cfg_attr(target_arch = "wasm32", allow(dead_code))]
    work_sender: Sender<ChunkRequest>,
    /// Channel to receive completed chunks (Native only).
    #[cfg_attr(target_arch = "wasm32", allow(dead_code))]
    result_receiver: Receiver<ChunkResult>,
}

impl WorldManager {
    /// Creates a new world manager with async worker thread.
    /// On WASM, runs synchronously on main thread (no threading support).
    ///
    /// # Arguments
    ///
    /// * `seed` - World seed for procedural generation
    /// * `config` - World manager configuration
    #[must_use]
    pub fn new(seed: WorldSeed, config: WorldManagerConfig) -> Self {
        // Create channels for async communication
        let (work_sender, work_receiver) = channel::<ChunkRequest>();
        let (result_sender, result_receiver) = channel::<ChunkResult>();
        
        // Shared generator for worker thread
        let generator = Arc::new(ChunkGenerator::new(seed));
        
        // WASM: No threading support - chunks generated synchronously in flush_generation_queue
        // Native: Spawn dedicated worker thread for background generation
        #[cfg(not(target_arch = "wasm32"))]
        {
            let gen_clone = Arc::clone(&generator);
            
            // Spawn single dedicated worker thread for chunk generation
            // This keeps the main thread free for rendering
            println!("[ASYNC] Starting chunk generation worker thread");
            
            thread::spawn(move || {
                loop {
                    // Wait for work (blocks this thread, not main!)
                    let Ok(request) = work_receiver.recv() else {
                        break; // Channel closed, exit worker
                    };
                    
                    println!("[ASYNC] Started generating Chunk [{},{}]", request.coord.x, request.coord.z);
                    
                    let start = Instant::now();
                    let chunk = gen_clone.generate(request.coord);
                    let gen_time_us = start.elapsed().as_micros() as u64;
                    
                    println!("[ASYNC] Finished Chunk [{},{}] in {}μs",
                        request.coord.x, request.coord.z, gen_time_us);
                    
                    // Send result back to main thread
                    let _ = result_sender.send(ChunkResult {
                        coord: request.coord,
                        chunk,
                        gen_time_us,
                    });
                }
            });
        }
        
        #[cfg(target_arch = "wasm32")]
        {
            // On WASM, we keep the receiver to avoid compiler errors
            // but chunks are generated synchronously in flush_generation_queue
            let _ = work_receiver; // Suppress unused warning
            let _ = result_sender;
            println!("[WASM] Running in single-threaded mode");
        }
        
        Self {
            generator,
            config,
            loaded_chunks: HashMap::with_capacity(512),
            generation_queue: VecDeque::with_capacity(256),
            queued_set: HashSet::with_capacity(256),
            in_flight: HashSet::with_capacity(64),
            player_chunk: ChunkCoord::new(i32::MAX, i32::MAX),
            modification_log: HashMap::new(),
            stats: WorldStats::default(),
            current_tick: 0,
            work_sender,
            result_receiver,
        }
    }

    /// Creates a world manager with default config.
    #[must_use]
    pub fn with_seed(seed: WorldSeed) -> Self {
        Self::new(seed, WorldManagerConfig::default())
    }

    /// Returns the current statistics.
    #[must_use]
    pub fn stats(&self) -> &WorldStats {
        &self.stats
    }

    /// Returns the number of loaded chunks.
    #[must_use]
    pub fn loaded_chunk_count(&self) -> usize {
        self.loaded_chunks.len()
    }

    /// Returns the current player chunk position.
    #[must_use]
    pub fn player_chunk(&self) -> ChunkCoord {
        self.player_chunk
    }

    /// Calculates chunk coordinate from world position.
    ///
    /// # Arguments
    ///
    /// * `x` - World X position
    /// * `z` - World Z position
    #[inline]
    #[must_use]
    pub fn world_to_chunk(x: f32, z: f32) -> ChunkCoord {
        // Handle negative coordinates correctly
        let chunk_x = if x >= 0.0 {
            (x / CHUNK_SIZE as f32) as i32
        } else {
            ((x / CHUNK_SIZE as f32).floor()) as i32
        };
        
        let chunk_z = if z >= 0.0 {
            (z / CHUNK_SIZE as f32) as i32
        } else {
            ((z / CHUNK_SIZE as f32).floor()) as i32
        };
        
        ChunkCoord::new(chunk_x, chunk_z)
    }

    /// Updates the world manager with the player's current position.
    ///
    /// This is the main entry point called each frame.
    ///
    /// # Arguments
    ///
    /// * `player_x` - Player world X position
    /// * `player_z` - Player world Z position
    ///
    /// # Returns
    ///
    /// Number of chunks generated this frame.
    pub fn update(&mut self, player_x: f32, player_z: f32) -> usize {
        self.current_tick += 1;
        
        let new_player_chunk = Self::world_to_chunk(player_x, player_z);
        
        // Only recalculate if player moved to a new chunk
        if new_player_chunk != self.player_chunk {
            self.player_chunk = new_player_chunk;
            self.recalculate_active_chunks();
        }
        
        // Process generation queue
        self.process_generation_queue()
    }

    /// Recalculates which chunks should be loaded/unloaded.
    fn recalculate_active_chunks(&mut self) {
        let center = self.player_chunk;
        let load_radius = self.config.load_radius;
        let unload_radius = self.config.unload_radius;
        
        let mut queued_this_frame = 0;
        
        // Queue chunks within load radius
        for dz in -load_radius..=load_radius {
            for dx in -load_radius..=load_radius {
                let coord = ChunkCoord::new(center.x + dx, center.z + dz);
                
                // Skip if already loaded, queued, or in-flight
                if self.loaded_chunks.contains_key(&coord) 
                    || self.queued_set.contains(&coord)
                    || self.in_flight.contains(&coord) {
                    continue;
                }
                
                // Check if within circular radius (not square)
                let dist_sq = dx * dx + dz * dz;
                if dist_sq <= load_radius * load_radius {
                    self.generation_queue.push_back(coord);
                    self.queued_set.insert(coord);
                    queued_this_frame += 1;
                }
            }
        }
        
        // Log only significant queue additions (not spammy)
        if queued_this_frame > 0 && ASYNC_VERBOSE {
            println!("[ASYNC] Queued {} new chunks, total pending: {}", 
                queued_this_frame, self.generation_queue.len() + self.in_flight.len());
        }
        
        // Unload chunks beyond unload radius
        let to_unload: Vec<ChunkCoord> = self.loaded_chunks
            .keys()
            .filter(|coord| {
                let dx = coord.x - center.x;
                let dz = coord.z - center.z;
                let dist_sq = dx * dx + dz * dz;
                dist_sq > unload_radius * unload_radius
            })
            .copied()
            .collect();
        
        for coord in to_unload {
            self.unload_chunk(coord);
        }
    }

    /// Processes the generation queue.
    /// 
    /// Native: Uses async worker thread (NON-BLOCKING)
    /// WASM: Generates synchronously on main thread
    fn process_generation_queue(&mut self) -> usize {
        let mut generated = 0;
        
        // Native: Async worker thread processing
        #[cfg(not(target_arch = "wasm32"))]
        {
            // 1. RECEIVE: Collect any completed chunks from worker (non-blocking)
            while let Ok(result) = self.result_receiver.try_recv() {
                self.in_flight.remove(&result.coord);
                
                // Apply any saved modifications
                let mut chunk = result.chunk;
                if let Some(modifications) = self.modification_log.get(&result.coord) {
                    for m in modifications {
                        chunk.set_block(
                            m.local_x as usize,
                            m.y as usize,
                            m.local_z as usize,
                            crate::chunk::Block::new(m.block_id),
                        );
                    }
                }
                
                self.loaded_chunks.insert(result.coord, chunk);
                generated += 1;
                self.stats.generated_this_session += 1;
                
                if ASYNC_VERBOSE {
                    println!("[ASYNC] Received Chunk [{},{}] - {}μs generation time",
                        result.coord.x, result.coord.z, result.gen_time_us);
                }
            }
            
            // 2. SEND: Dispatch new chunks to worker (up to max per frame)
            let mut dispatched = 0;
            while dispatched < self.config.max_chunks_per_frame && !self.generation_queue.is_empty() {
                // Don't overload the worker - limit in-flight chunks
                if self.in_flight.len() >= 32 {
                    break;
                }
                
                let Some(coord) = self.generation_queue.pop_front() else {
                    break;
                };
                
                self.queued_set.remove(&coord);
                
                // Send to worker thread (non-blocking)
                if self.work_sender.send(ChunkRequest { coord }).is_ok() {
                    self.in_flight.insert(coord);
                    dispatched += 1;
                    
                    if ASYNC_VERBOSE {
                        println!("[ASYNC] Dispatched Chunk [{},{}] to worker", coord.x, coord.z);
                    }
                }
            }
        }
        
        // WASM: Synchronous generation on main thread (no threading)
        #[cfg(target_arch = "wasm32")]
        {
            let mut processed = 0;
            while processed < self.config.max_chunks_per_frame && !self.generation_queue.is_empty() {
                let Some(coord) = self.generation_queue.pop_front() else {
                    break;
                };
                
                self.queued_set.remove(&coord);
                
                // Generate synchronously
                let mut chunk = self.generator.generate(coord);
                
                // Apply any saved modifications
                if let Some(modifications) = self.modification_log.get(&coord) {
                    for m in modifications {
                        chunk.set_block(
                            m.local_x as usize,
                            m.y as usize,
                            m.local_z as usize,
                            crate::chunk::Block::new(m.block_id),
                        );
                    }
                }
                
                self.loaded_chunks.insert(coord, chunk);
                generated += 1;
                processed += 1;
                self.stats.generated_this_session += 1;
            }
        }
        
        // Update stats
        self.stats.loaded_chunks = self.loaded_chunks.len();
        self.stats.pending_chunks = self.generation_queue.len() + self.in_flight.len();
        
        generated
    }

    /// Unloads a chunk, saving if modified.
    fn unload_chunk(&mut self, coord: ChunkCoord) {
        if let Some(chunk) = self.loaded_chunks.remove(&coord) {
            if chunk.modified {
                // Chunk was modified - we would save to WAL here
                self.stats.saved_modified_chunks += 1;
                // Note: Actual WAL integration would be done via callback
            }
            self.stats.unloaded_this_session += 1;
        }
    }

    /// Gets a loaded chunk at the given coordinate.
    #[must_use]
    pub fn get_chunk(&self, coord: ChunkCoord) -> Option<&Chunk> {
        self.loaded_chunks.get(&coord)
    }

    /// Gets a mutable loaded chunk at the given coordinate.
    pub fn get_chunk_mut(&mut self, coord: ChunkCoord) -> Option<&mut Chunk> {
        self.loaded_chunks.get_mut(&coord)
    }

    /// Gets a block at world coordinates.
    ///
    /// Returns None if the chunk is not loaded.
    #[must_use]
    pub fn get_block(&self, world_x: i32, world_y: i32, world_z: i32) -> Option<crate::chunk::Block> {
        if world_y < 0 || world_y >= 256 {
            return None;
        }
        
        let chunk_coord = ChunkCoord::from_world_pos(world_x, world_z);
        let chunk = self.loaded_chunks.get(&chunk_coord)?;
        
        let local_x = world_x.rem_euclid(CHUNK_SIZE as i32) as usize;
        let local_z = world_z.rem_euclid(CHUNK_SIZE as i32) as usize;
        
        Some(chunk.get_block(local_x, world_y as usize, local_z))
    }

    /// Sets a block at world coordinates.
    ///
    /// Returns false if the chunk is not loaded.
    pub fn set_block(&mut self, world_x: i32, world_y: i32, world_z: i32, block_id: u16) -> bool {
        if world_y < 0 || world_y >= 256 {
            return false;
        }
        
        let chunk_coord = ChunkCoord::from_world_pos(world_x, world_z);
        let Some(chunk) = self.loaded_chunks.get_mut(&chunk_coord) else {
            return false;
        };
        
        let local_x = world_x.rem_euclid(CHUNK_SIZE as i32) as usize;
        let local_z = world_z.rem_euclid(CHUNK_SIZE as i32) as usize;
        
        chunk.set_block(local_x, world_y as usize, local_z, crate::chunk::Block::new(block_id));
        
        // Record modification for persistence
        let modification = ChunkModification {
            local_x: local_x as u8,
            y: world_y as u8,
            local_z: local_z as u8,
            block_id,
            tick: self.current_tick,
        };
        
        self.modification_log
            .entry(chunk_coord)
            .or_insert_with(Vec::new)
            .push(modification);
        
        true
    }

    /// Checks the state of a chunk.
    #[must_use]
    pub fn chunk_state(&self, coord: ChunkCoord) -> ChunkState {
        if self.loaded_chunks.contains_key(&coord) {
            ChunkState::Loaded
        } else if self.queued_set.contains(&coord) {
            ChunkState::Pending
        } else {
            ChunkState::Unloaded
        }
    }

    /// Forces immediate generation of all pending chunks.
    ///
    /// Use sparingly - this can cause frame drops.
    pub fn flush_generation_queue(&mut self) {
        // Native: First, drain any in-flight results from worker thread
        #[cfg(not(target_arch = "wasm32"))]
        {
            while let Ok(result) = self.result_receiver.try_recv() {
                self.in_flight.remove(&result.coord);
                self.loaded_chunks.insert(result.coord, result.chunk);
                self.stats.generated_this_session += 1;
            }
        }
        
        // Generate remaining queued chunks synchronously (both Native & WASM)
        while let Some(coord) = self.generation_queue.pop_front() {
            self.queued_set.remove(&coord);
            
            let mut chunk = self.generator.generate(coord);
            if let Some(modifications) = self.modification_log.get(&coord) {
                for m in modifications {
                    chunk.set_block(
                        m.local_x as usize,
                        m.y as usize,
                        m.local_z as usize,
                        crate::chunk::Block::new(m.block_id),
                    );
                }
            }
            
            self.loaded_chunks.insert(coord, chunk);
            self.stats.generated_this_session += 1;
        }
        
        // Native: Wait for in-flight to complete
        // WASM: No in-flight chunks (no worker thread)
        #[cfg(not(target_arch = "wasm32"))]
        {
            while !self.in_flight.is_empty() {
                if let Ok(result) = self.result_receiver.recv() {
                    self.in_flight.remove(&result.coord);
                    self.loaded_chunks.insert(result.coord, result.chunk);
                    self.stats.generated_this_session += 1;
                }
            }
        }
        
        self.stats.loaded_chunks = self.loaded_chunks.len();
        self.stats.pending_chunks = 0;
    }

    /// Loads modification data from a WAL or external source.
    ///
    /// Call this before starting gameplay to restore player changes.
    pub fn load_modifications(&mut self, modifications: Vec<ModificationEntry>) {
        for entry in modifications {
            self.modification_log.insert(entry.coord, entry.modifications);
        }
    }

    /// Exports all modifications for WAL persistence.
    #[must_use]
    pub fn export_modifications(&self) -> Vec<ModificationEntry> {
        self.modification_log
            .iter()
            .map(|(coord, mods)| ModificationEntry {
                coord: *coord,
                modifications: mods.clone(),
            })
            .collect()
    }

    /// Returns true if the given world position has ground beneath it.
    ///
    /// Used for collision detection / void fall prevention.
    #[must_use]
    pub fn has_ground(&self, world_x: i32, world_y: i32, world_z: i32) -> bool {
        // Check if chunk is loaded
        let chunk_coord = ChunkCoord::from_world_pos(world_x, world_z);
        let Some(chunk) = self.loaded_chunks.get(&chunk_coord) else {
            // Chunk not loaded - assume there's ground (safe default)
            return true;
        };
        
        let local_x = world_x.rem_euclid(CHUNK_SIZE as i32) as usize;
        let local_z = world_z.rem_euclid(CHUNK_SIZE as i32) as usize;
        
        // Check from current position down to bedrock
        for y in (0..world_y.min(255) as usize).rev() {
            let block = chunk.get_block(local_x, y, local_z);
            if !block.is_air() {
                return true;
            }
        }
        
        false
    }

    /// Ensures all chunks around a position are loaded.
    ///
    /// Blocks until generation is complete. Use for spawn point.
    pub fn ensure_loaded_around(&mut self, world_x: f32, world_z: f32, radius: i32) {
        let center = Self::world_to_chunk(world_x, world_z);
        println!("[ASYNC] Synchronously loading spawn area ({}x{} chunks)...", 
            radius * 2 + 1, radius * 2 + 1);
        
        let start = Instant::now();
        let mut loaded = 0;
        
        for dz in -radius..=radius {
            for dx in -radius..=radius {
                let coord = ChunkCoord::new(center.x + dx, center.z + dz);
                
                if !self.loaded_chunks.contains_key(&coord) {
                    // Direct generation (blocking) for spawn area only
                    let mut chunk = self.generator.generate(coord);
                    
                    // Apply any saved modifications
                    if let Some(modifications) = self.modification_log.get(&coord) {
                        for m in modifications {
                            chunk.set_block(
                                m.local_x as usize,
                                m.y as usize,
                                m.local_z as usize,
                                crate::chunk::Block::new(m.block_id),
                            );
                        }
                    }
                    
                    self.loaded_chunks.insert(coord, chunk);
                    self.stats.generated_this_session += 1;
                    loaded += 1;
                }
            }
        }
        
        println!("[ASYNC] Spawn area ready: {} chunks in {:?}", loaded, start.elapsed());
        self.stats.loaded_chunks = self.loaded_chunks.len();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_world_to_chunk_positive() {
        // Block at (17, 5) should be in chunk (1, 0)
        let coord = WorldManager::world_to_chunk(17.0, 5.0);
        assert_eq!(coord.x, 1);
        assert_eq!(coord.z, 0);
    }

    #[test]
    fn test_world_to_chunk_negative() {
        // Block at (-17, -5) should be in chunk (-2, -1)
        let coord = WorldManager::world_to_chunk(-17.0, -5.0);
        assert_eq!(coord.x, -2);
        assert_eq!(coord.z, -1);
    }

    #[test]
    fn test_world_to_chunk_boundary() {
        // Block at (16, 16) should be in chunk (1, 1)
        let coord = WorldManager::world_to_chunk(16.0, 16.0);
        assert_eq!(coord.x, 1);
        assert_eq!(coord.z, 1);
        
        // Block at (15.9, 15.9) should be in chunk (0, 0)
        let coord = WorldManager::world_to_chunk(15.9, 15.9);
        assert_eq!(coord.x, 0);
        assert_eq!(coord.z, 0);
    }

    #[test]
    fn test_initial_chunk_loading() {
        let seed = WorldSeed::new(12345);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::test());
        
        // Player at origin
        manager.update(8.0, 8.0);
        manager.flush_generation_queue();
        
        // With radius 3, we should have chunks in a circle
        // Circle area ≈ π * r² ≈ 28, but discrete grid means fewer
        // Actually count chunks within radius 3: about 29 (including center)
        assert!(manager.loaded_chunk_count() > 0, "Should load at least some chunks");
        assert!(manager.loaded_chunk_count() < 100, "Should not load too many chunks");
        
        // Center chunk should definitely be loaded
        let center = WorldManager::world_to_chunk(8.0, 8.0);
        assert!(manager.get_chunk(center).is_some());
    }

    #[test]
    fn test_chunk_unloading() {
        let seed = WorldSeed::new(12345);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::test());
        
        // Player at origin
        manager.update(0.0, 0.0);
        manager.flush_generation_queue();
        let initial_count = manager.loaded_chunk_count();
        assert!(initial_count > 0, "Should have loaded some chunks");
        
        // Move player far away (beyond unload radius * CHUNK_SIZE)
        // With test config: unload_radius = 4, so move > 4 * 16 = 64 blocks
        manager.update(200.0, 200.0);
        manager.flush_generation_queue();
        
        // Old chunks should be unloaded
        let origin_chunk = ChunkCoord::new(0, 0);
        assert!(
            manager.get_chunk(origin_chunk).is_none(),
            "Origin chunk should be unloaded after moving far away"
        );
        
        // Stats should show unloading occurred
        assert!(
            manager.stats().unloaded_this_session > 0,
            "Should have unloaded {} chunks", initial_count
        );
    }

    #[test]
    fn test_walking_50_meters_no_void() {
        let seed = WorldSeed::new(42);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::test());
        
        // Start at origin
        let mut x = 0.0f32;
        let z = 0.0f32;
        
        manager.ensure_loaded_around(x, z, 5);
        
        // Walk 50 meters (blocks) in X direction
        for _ in 0..50 {
            x += 1.0;
            manager.update(x, z);
            manager.flush_generation_queue();
            
            // Check ground exists at current position
            let has_ground = manager.has_ground(x as i32, 100, z as i32);
            assert!(has_ground, "No ground at x={}", x);
        }
    }

    #[test]
    fn test_walking_500_meters_no_void() {
        let seed = WorldSeed::new(42);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::production());
        
        let mut x = 0.0f32;
        let z = 0.0f32;
        
        manager.ensure_loaded_around(x, z, 5);
        
        // Walk 500 meters
        for step in 0..500 {
            x += 1.0;
            manager.update(x, z);
            
            // Process some chunks each frame
            if step % 10 == 0 {
                manager.flush_generation_queue();
            }
            
            // Verify chunk at current position is loaded or pending
            let chunk_coord = WorldManager::world_to_chunk(x, z);
            let state = manager.chunk_state(chunk_coord);
            assert!(
                state == ChunkState::Loaded || state == ChunkState::Pending,
                "Chunk {:?} at x={} is unloaded!", chunk_coord, x
            );
        }
        
        manager.flush_generation_queue();
        
        // Final position should have ground
        assert!(manager.has_ground(x as i32, 100, z as i32));
    }

    #[test]
    fn test_block_modification_persistence() {
        let seed = WorldSeed::new(12345);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::test());
        
        // Load chunks at origin
        manager.ensure_loaded_around(0.0, 0.0, 2);
        
        // Modify a block
        let success = manager.set_block(5, 64, 5, 100); // Set custom block
        assert!(success);
        
        // Export modifications
        let mods = manager.export_modifications();
        assert!(!mods.is_empty());
        
        // Create new manager and load modifications
        let mut manager2 = WorldManager::new(seed, WorldManagerConfig::test());
        manager2.load_modifications(mods);
        manager2.ensure_loaded_around(0.0, 0.0, 2);
        
        // Block should be restored
        let block = manager2.get_block(5, 64, 5);
        assert!(block.is_some());
        assert_eq!(block.unwrap().id, 100);
    }

    #[test]
    fn test_diagonal_walk_infinite() {
        let seed = WorldSeed::new(999);
        let mut manager = WorldManager::new(seed, WorldManagerConfig::production());
        
        let mut x = 0.0f32;
        let mut z = 0.0f32;
        
        manager.ensure_loaded_around(x, z, 5);
        
        // Walk diagonally 200 meters
        for _ in 0..200 {
            x += 0.7; // ~45 degree angle
            z += 0.7;
            
            manager.update(x, z);
        }
        
        manager.flush_generation_queue();
        
        // Should have ground at final position
        assert!(manager.has_ground(x as i32, 100, z as i32));
        
        // Return home - old chunks will regenerate
        manager.update(0.0, 0.0);
        manager.flush_generation_queue();
        
        // Origin should still work
        assert!(manager.has_ground(0, 100, 0));
    }
}
